10.1
You may find that your algo is incorrect while tracing through BF example at the algo stage (perhaps you didn't understand some aspect of the question), don't hesitate to start from scratch. Different algo means you may need to ask for different clarifying questions and change examples

as long as <condition>
--
Palindrome Partitioning
Given a string s, partition s such that every substring of the partition is a palindrome.
Return all possible palindrome partitioning of s.
For example, given s = �aab�, Return
[
["aa","b"],
["a","a","b"]
]
--
std::vector<std::vector<std::string>> getPalindromePartitions(const std::string& str)
--
space ?

"aba" => {"a", "b", "a"}, {"aba"} 
"abc" => {"a", "b", "c"} 
"aaa" => {single chars}, {"a", "aa"}, {"aa", "a"}, {"aaa"}, 

"" -> {}
" a" -> {" ", "a"}
"agfgb" => {sigle chars}, {a, gfg, b}
--
Algo

isPalindrome(str)
	traverse from left and right towards center as long as leftIdx <= rightIdx  
		if chars don't match, return false
	return true
	
f(str, curRes, finalRes)
	if str is empty
		add curRes to finalRes
	
	consider all widths from 1 through str.size()
		if str.substr(0, width) is a palindrome
			 add that substr to curRes
			 f(str.substr(startIdx), curRes, finalRes)
			 remove that substr from curRes
--
Time and space complexity? 
N^2 time, 

N space due to N recursive calls in the worst case (single char case) 
Each partition is of size N * N partitions in the worst case so N^2
Total N + N^2 = N^2  
--
Code

#include <iostream>
#include <stdexcept>
#include <string>
#include <vector>
 	
bool isPalindrome(const std::string& str) {
	if(str.empty()){
		return true;
	}
	int startIdx = 0, endIdx = str.size() - 1;
	
	while(startIdx <= endIdx) {
		if(str[startIdx] != str[endIdx]) {
			return false;
		}
		++startIdx;
		--endIdx;
	}
	return true;
}

void getPalPartitionHelper(std::vector<std::string>* curResPtr, std::vector<std::vector<std::string>>* resPtr, const std::string& str) {
 
 	if(str.empty()) {
 		resPtr->emplace_back(curRes); 	
 		return;
 	}
 
 	for(size_t width = 1; width <= str.size(); ++width) {
 		const std::string& subStr = str.substr(0, width);
 		if(isPalindrome(subStr)) {
 			curResPtr->emplace_back(subStr);
 			getPalPartitionHelper(curResPtr, resPtr, str.substr(width));
 			curResPtr->pop_back();
 		}
 	}
 }
 

std::vector<std::vector<std::string>> getPalindromePartitions(const std::string& str) {
 	std::vector<std::vector<std::string>> res{};
 	std::vector<std::string> curRes{};
 	
 	if(str.empty()) {
 		return res;
 	}
 	
 	getPalPartitionHelper(&curRes, &res, str);
 
 }
 